name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - master
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - 'LICENSE'
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      force_runtime_build:
        description: 'Force rebuild runtime image'
        required: false
        type: boolean
        default: false

env:
  DOCKER_USERNAME: luongnguyenminhan
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  REGISTRY: luongnguyenminhan

jobs:
  # Stage 1: Check if runtime image exists
  check-runtime:
    name: Check Runtime Image
    runs-on: ubuntu-latest
    outputs:
      runtime-exists: ${{ steps.check.outputs.exists }}
      runtime-image: ${{ steps.image.outputs.runtime }}
    steps:
      - name: Set image name
        id: image
        run: |
          echo "runtime=luongnguyenminhan/securescribe:backend-runtime" >> $GITHUB_OUTPUT

      - name: üê≥ Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_PASSWORD }}

      - name: ‚úÖ Check if runtime image exists
        id: check
        run: |
          if docker pull luongnguyenminhan/securescribe:backend-runtime 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Runtime image already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Runtime image does not exist, will build"
          fi

  # Stage 1b: Build Runtime Image (only if not exists or forced)
  build-runtime:
    name: Build Runtime Image
    runs-on: ubuntu-latest
    needs: check-runtime
    if: needs.check-runtime.outputs.runtime-exists == 'false' || github.event.inputs.force_runtime_build == 'true'
    outputs:
      runtime-image: ${{ needs.check-runtime.outputs.runtime-image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üê≥ Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_PASSWORD }}

      - name: üî® Build and push runtime image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./build/Dockerfile.runtime
          push: true
          tags: |
            ${{ needs.check-runtime.outputs.runtime-image }}

      - name: ‚úÖ Runtime image built successfully
        run: |
          echo "üéâ Runtime image: ${{ needs.check-runtime.outputs.runtime-image }}"

  # Stage 2: Build Backend Image
  build-backend:
    name: Build Backend Image
    runs-on: ubuntu-latest
    needs: check-runtime
    outputs:
      backend-image: ${{ steps.image.outputs.backend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set image name
        id: image
        run: |
          echo "backend=luongnguyenminhan/securescribe:backend" >> $GITHUB_OUTPUT

      - name: üê≥ Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_PASSWORD }}

      - name: üî® Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./build/Dockerfile.app
          push: true
          build-args: |
            RUNTIME_IMAGE=luongnguyenminhan/securescribe:backend-runtime
          tags: |
            ${{ steps.image.outputs.backend }}

  # Stage 3: Run Tests
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: build-backend
    services:
      db:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: admin
          POSTGRES_PASSWORD: admin
          POSTGRES_DB: securescribe
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379

      minio:
        image: minio/minio:latest
        env:
          MINIO_ACCESS_KEY: minioadmin
          MINIO_SECRET_KEY: minioadmin
        ports:
          - 9000:9000
          - 9001:9001
        options: >-
          --entrypoint sh
          -c "mkdir -p /data && minio server /data --address ':9000' --console-address ':9001'"

      qdrant:
        image: qdrant/qdrant:latest
        ports:
          - 6333:6333
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client redis-tools curl

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt pytest pytest-cov pytest-asyncio

      - name: Wait for services to be ready
        run: |
          # Wait for PostgreSQL
          for i in {1..30}; do
            if pg_isready -h localhost -p 5432 -U admin; then
              echo "PostgreSQL is ready"
              break
            fi
            echo "Waiting for PostgreSQL... ($i/30)"
            sleep 2
          done

          # Wait for Redis
          for i in {1..30}; do
            if redis-cli -h localhost -p 6379 ping | grep -q PONG; then
              echo "Redis is ready"
              break
            fi
            echo "Waiting for Redis... ($i/30)"
            sleep 2
          done

          # Wait for MinIO
          for i in {1..30}; do
            if curl -f http://localhost:9000/minio/health/ready; then
              echo "MinIO is ready"
              break
            fi
            echo "Waiting for MinIO... ($i/30)"
            sleep 2
          done

          # Wait for Qdrant
          for i in {1..30}; do
            if curl -f http://localhost:6333/health; then
              echo "Qdrant is ready"
              break
            fi
            echo "Waiting for Qdrant... ($i/30)"
            sleep 2
          done

      - name: Create coverage directory
        run: mkdir -p coverage_reports

      - name: üß™ Run tests with coverage
        run: |
          pytest tests/ -v \
            --cov=app \
            --cov-report=html:coverage_reports/html \
            --cov-report=term-missing \
            --cov-report=xml:coverage_reports/coverage.xml \
            --junitxml=coverage_reports/junit.xml \
            --tb=short
        env:
          POSTGRES_SERVER: localhost
          POSTGRES_PORT: 5432
          POSTGRES_USER: admin
          POSTGRES_PASSWORD: admin
          POSTGRES_DB: securescribe
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          REDIS_DB: 0
          MINIO_ENDPOINT: localhost:9000
          MINIO_ACCESS_KEY: minioadmin
          MINIO_SECRET_KEY: minioadmin
          MINIO_SECURE: false
          MINIO_BUCKET_NAME: securescribe-files
          MINIO_PUBLIC_BUCKET_NAME: securescribe-public
          QDRANT_HOST: localhost
          QDRANT_PORT: 6333
          QDRANT_COLLECTION_NAME: documents
          SECRET_KEY: test-secret-key-for-ci
          BACKEND_CORS_ORIGINS: http://localhost:3000

      - name: üìä Generate comprehensive test report
        if: always()
        run: |
          python .github/scripts/generate_test_report.py

      - name: üìà Generate coverage badge
        if: always()
        run: |
          python .github/scripts/generate_coverage_badge.py

      - name: üìä Upload coverage reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports
          path: coverage_reports/
          retention-days: 30

      - name: üìä Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: coverage_reports/junit.xml
          retention-days: 30

      - name: üìà Publish test results
        uses: EnricoMi/publish-unit-test-result-action@v2
        if: always()
        with:
          files: coverage_reports/junit.xml
          check_name: Test Results
          comment_title: Test Execution Report

      - name: üî¥ Fail if tests failed
        if: failure()
        run: |
          echo "‚ùå Tests failed! Check the test results above."
          exit 1

  # Stage 4: Test Failure Notification
  test-notification:
    name: Test Failure Notification
    runs-on: ubuntu-latest
    needs: test
    if: failure() && needs.test.result == 'failure'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: üìß Notify on test failure
        run: |
          echo "Test job failed. Generating failure report..."
          echo "Workflow: ${{ github.workflow }}"
          echo "Branch: ${{ github.ref }}"
          echo "Commit: ${{ github.sha }}"
          echo "Author: ${{ github.actor }}"
          echo "Run URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

      - name: üí¨ Comment on PR with test failure
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚ùå **Test Execution Failed**\n\n` +
                    `Tests failed in this PR. Please review the [test results](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}).\n\n` +
                    `**Details:**\n` +
                    `- Branch: \`${{ github.ref }}\`\n` +
                    `- Commit: \`${{ github.sha }}\`\n` +
                    `- Author: @${{ github.actor }}`
            })

  # Stage 5: Deploy (only on push to main/master)
  # Final: Summary
  pipeline-summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs: [build-runtime, build-backend, test]
    if: always()
    steps:
      - name: üìä Pipeline Summary
        run: |
          echo "=========================================="
          echo "‚úÖ Pipeline Execution Summary"
          echo "=========================================="
          echo "Build Runtime: ${{ needs.build-runtime.result }}"
          echo "Build Backend: ${{ needs.build-backend.result }}"
          echo "Run Tests: ${{ needs.test.result }}"
          echo "=========================================="

      - name: üìà Coverage Badge Update
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          echo "Coverage badge would be updated here"
          echo "This step can be extended to update coverage badges in README"
